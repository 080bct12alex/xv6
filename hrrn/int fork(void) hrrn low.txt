int fork(void)
{
    int i, pid;
    struct proc *np;
    struct proc *p = myproc();

    // Allocate process
    if((np = allocproc()) == 0){
        return -1;
    }

    // Copy user memory
    if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
        freeproc(np);
        release(&np->lock);
        return -1;
    }
    np->sz = p->sz;

    // Copy registers
    *(np->trapframe) = *(p->trapframe);
    np->trapframe->a0 = 0;  // child returns 0

    // Copy open files
    for(i = 0; i < NOFILE; i++)
        if(p->ofile[i])
            np->ofile[i] = filedup(p->ofile[i]);
    np->cwd = idup(p->cwd);

    safestrcpy(np->name, p->name, sizeof(p->name));

    pid = np->pid;

    release(&np->lock);

    acquire(&wait_lock);
    np->parent = p;
    release(&wait_lock);

    // Set process RUNNABLE with correct enter_time and wtime
    acquire(&np->lock);
    np->state = RUNNABLE;

    acquire(&tickslock);
    np->enter_time = ticks;  // record when it becomes RUNNABLE
    release(&tickslock);

       release(&np->lock);

    return pid;
}
void yield(void)
{
    struct proc *p = myproc();
    acquire(&p->lock);
    p->state = RUNNABLE;

    acquire(&tickslock);
    p->enter_time = ticks;  // mark re-entry into RUNNABLE
    release(&tickslock);

      sched();
    release(&p->lock);
}
void wakeup(void *chan)
{
    struct proc *p;

    for(p = proc; p < &proc[NPROC]; p++){
        if(p != myproc()){
            acquire(&p->lock);
            if(p->state == SLEEPING && p->chan == chan){
                p->state = RUNNABLE;

                acquire(&tickslock);
                p->enter_time = ticks;  // mark RUNNABLE moment
                release(&tickslock);

                           }
            release(&p->lock);
        }
    }
}
static struct proc* allocproc(void) { struct proc *p; for(p = proc; p < &proc[NPROC]; p++) { acquire(&p->lock); if(p->state == UNUSED) { goto found; } else { release(&p->lock); } } return 0; found: p->pid = allocpid(); p->state = USED; // Initialize HRRN fields p->rtime = 0; // total running time p->wtime = 0; // waiting time p->enter_time = 0; // first time process becomes RUNNABLE // Allocate a trapframe page. if((p->trapframe = (struct trapframe *)kalloc()) == 0){ freeproc(p); release(&p->lock); return 0; } // An empty user page table. p->pagetable = proc_pagetable(p); if(p->pagetable == 0){ freeproc(p); release(&p->lock); return 0; } // Set up new context to start executing at forkret, // which returns to user space. memset(&p->context, 0, sizeof(p->context)); p->context.ra = (uint64)forkret; p->context.sp = p->kstack + PGSIZE; return p; }    


void
clockintr()
{
    if(cpuid() == 0){
        acquire(&tickslock);
        ticks++;
        wakeup(&ticks);
        release(&tickslock);
    }

    // Per-process accounting
    for(struct proc *p = proc; p < &proc[NPROC]; p++){
        acquire(&p->lock);
        if(p->state == RUNNING)
            p->rtime++;      // increment runtime for RUNNING processes
        else if(p->state == RUNNABLE)
            p->wtime++;      // increment waiting time for RUNNABLE processes
        release(&p->lock);
    }

    // schedule next timer interrupt (about 0.1s)
    w_stimecmp(r_time() + 1000000);
}


// ---------------- HRRN scheduler (integer-only, constant burst) ----------------


void scheduler(void)
{
    struct proc *p, *best_proc;
    struct cpu *c = mycpu();
    c->proc = 0;

   

    for(;;){
        intr_on();  // enable interrupts

        best_proc = 0;
        uint64 best_num = 0;   // numerator of best RR (wait + burst)
        uint64 best_den = 1;   // denominator of best RR (burst) -- kept for generality

        // pick RUNNABLE process with highest response ratio
        for(p = proc; p < &proc[NPROC]; p++){
            acquire(&p->lock);
            if(p->state == RUNNABLE){
                uint64 wait_time;
                uint64 burst_time = p->burst;

               

                // ensure enter_time initialized (allocproc sets to 0). If still 0 treat it as now.
                wait_time = p->wtime;

                uint64 num = wait_time + burst_time; // numerator of RR
                uint64 den = burst_time;             // denominator of RR

                // Compare num/den > best_num/best_den via cross-multiplication
                // (num * best_den) > (best_num * den)
                if(best_proc == 0 || (num * best_den) > (best_num * den)) {
                    if(best_proc && best_proc != p)
                        release(&best_proc->lock);

                    best_num = num;
                    best_den = den;
                    best_proc = p;  // keep lock held on best_proc
                } else {
                    release(&p->lock);
                }
            } else {
                release(&p->lock);
            }
        }

        if(best_proc){
            // Run the chosen process
            best_proc->state = RUNNING;
            c->proc = best_proc;

// After running, reset waiting so fresh cycle can accumulate best_proc->wtime = 0;

            swtch(&c->context, &best_proc->context); // context switch

            
            c->proc = 0;
            release(&best_proc->lock);
        } else {
            // No RUNNABLE process, wait for interrupt
            asm volatile("wfi");
        }

        // Safe place to print stats (no scheduler locks held here)
        print_proc_stats();
    }
}

// ---------------- print_proc_stats() updated to avoid floating point ----------------
void print_proc_stats(void) {
    if(has_user_proc() == 0)
        return;

    struct proc *p;
    static int header_printed = 0;

    int pid_max = 3, name_max = 12, wait_max = 8, rt_max = 8;
    

    if(!header_printed){
        printf("\nPID  Name         Waiting  Runtime   RR\n");
        printf("-----------------------------------------\n");
        header_printed = 1;
    }

    for(p = proc; p < &proc[NPROC]; p++){
        acquire(&p->lock);
        if(p->name[0] != 0 &&
           strncmp(p->name, "init", 4) != 0 &&
           strncmp(p->name, "sh", 2) != 0 &&
           (p->state == RUNNABLE || p->state == RUNNING)) {

            uint64 wait_time;
            

           wait_time = p->wtime;
            

            uint64 burst_time = p->burst;;
            uint64 num = wait_time + burst_time; // numerator
            uint64 den = burst_time;             // denominator

            // compute scaled RR = (num / den) with two decimals, scaled by 100
            // rr_scaled = ((num * 100) + den/2) / den  -- rounded
            uint64 rr_scaled = (num * 100 + den/2) / den; // integer, e.g. 123 means 1.23

            // PID
            printf("%d", p->pid);
            for(int s = 0; s < pid_max - num_digits(p->pid) + 2; s++)
                printf(" ");

            // Name
            printf("%s", p->name);
            for(int s = 0; s < name_max - strlen(p->name) + 2; s++)
                printf(" ");

            // Waiting
            printf("%lu", wait_time);
            for(int s = 0; s < wait_max - num_digits(wait_time) + 2; s++)
                printf(" ");

            // Runtime (we can show rtime if you maintain it elsewhere)
            printf("%lu", p->rtime);
            for(int s = 0; s < rt_max - num_digits(p->rtime) + 2; s++)
                printf(" ");
// RR: print as X.YY using integer math (works in xv6)
printf("%lu.", rr_scaled / 100);       // integer part
if(rr_scaled % 100 < 10)
    printf("0");                       // leading zero
printf("%lu\n", rr_scaled % 100);     // decimal part


            
        }
        release(&p->lock);
    }
}

